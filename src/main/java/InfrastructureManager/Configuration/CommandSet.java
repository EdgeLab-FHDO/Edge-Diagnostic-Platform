package InfrastructureManager.Configuration;


import InfrastructureManager.Configuration.Exception.ResponseNotDefinedException;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Represent a set of command-response pairs, that define a connection between two modules, specifically
 * between an input and an output.
 * Also, includes functionalities to process parameterized commands and map them to standard ones
 */
public class CommandSet {

    /**
     * Map representing the real command set. It has keys of String value, representing the "commands" and
     * values, also Strings, to represent the responses.
     */
    private Map<String,String> commands;

    /**
     * Auxiliary map to help with "$" parameter mapping. Stores the command as key (e.g "example" in
     * "example $param1 $param2") and as value a list of integers which are the positions of the parameters
     * to be replaced in the response
     */
    private final Map<String,List<Integer>> parameterMapping;

    /**
     * Constructor of the class. Initializes internal fields as {@link HashMap}.
     */
    public CommandSet() {
        this.commands = new HashMap<>();
        this.parameterMapping = new HashMap<>();
    }

    /**
     * Set the command set to a given map
     * @param config Map element containing the commands where for each entry, the key is the command and the value is the response.
     */
    public void set(Map<String, String> config) {
        this.commands = config;
        fillMapping();
    }

    /**
     * Return the commands in form of a map
     * @return Map element containing the commands where for each entry, the key is the command and the value is the response.
     */
    public Map<String, String> get() {
        return this.commands;
    }

    /**
     * Mapping method to get a certain defined response for a given command
     * @param command Command for which the response is wanted
     * @return Response defined for the given command
     * @throws IllegalArgumentException if the command is empty
     * @throws ResponseNotDefinedException if the given command is not defined or has no response defined
     */
    public String getResponse(String command) throws IllegalArgumentException, ResponseNotDefinedException {
        String[] commandAsArray;
        if (command.startsWith("fromDebug")) {
            // If the messages comes from a debug input, ignore the separation by spaces
            String message = command.replaceAll("fromDebug ","");
            commandAsArray = new String[] {"fromDebug", message};
        } else {
            commandAsArray = command.split(" ");
        }
        command = commandAsArray[0];
        if (command.isEmpty()) {
            throw new IllegalArgumentException("Empty Command at input!");
        } else {
            String response = getUnmappedResponse(commandAsArray); //Get raw response
            return mapCommand(commandAsArray,response); // Get response with values
        }
    }

    /**
     * Fills the parameter Mapping map, based on the "normal" command set. It fills it with keys
     * corresponding to the first part of the command and values obtained using the {@link #getMappingPositions(String)}
     * method, which are lists of Integers.
     */
    private void fillMapping() {
        for (String command : this.commands.keySet()){
            this.parameterMapping.put(command.split(" ")[0],getMappingPositions(command));
        }
    }


    /**
     * For a given complete command (separated by spaces) searches for the positions of arguments which
     * are present in both command and defined response. Normally these are the parameterized arguments of
     * the form {@code $PARAM}.
     * @param command Command generated by an input. Includes spaces
     * @return Positions of the parameters in the command that would need to be mapped in the response.
     */
    private List<Integer> getMappingPositions(String command) {
        List<Integer> result = new ArrayList<>();
        String[] commandAsArray = command.split(" ");
        String response = this.commands.get(command);
        for (int i = 1; i < commandAsArray.length; i++) {
            if (response.contains(commandAsArray[i])) {
                result.add(i);
            }
        }
        return result;
    }

    /**
     * Search for the raw ({@code $PARAM} parameters still unmapped) response of a given command.
     * Does so by searching the first part of the command array (split by spaces) in the command set map
     * and verifying that the same number of arguments is passed as it was defined originally
     * @param commandAsArray Command read from an input, separated by spaces into an array
     * @return Raw response for the given command
     * @throws ResponseNotDefinedException If the command cannot be found or the argument number defined is
     * not the same as the passed one.
     */
    private String getUnmappedResponse(String[] commandAsArray) throws ResponseNotDefinedException {
        String[] aux;
        for (String definedCommand : this.commands.keySet()) {
            if (definedCommand.startsWith(commandAsArray[0])) {
                aux = definedCommand.split(" ");
                if (aux.length == commandAsArray.length){
                    //If the definition and the passed command have the same number or arguments
                    return this.commands.get(definedCommand);
                }
            }
        }
        throw new ResponseNotDefinedException("Response could not be found for command " + commandAsArray[0]);
    }

    /**
     * Performs the mapping or parameterized arguments in commands (Arguments of the {@code $PARAM} form).
     * It does so by reading the parameter mapping map, to get the position in which values should be
     * substituted.
     * @param commandAsArray Command read from an input, separated by spaces into an array
     * @param response Raw response defined for the command, that includes the {@code $PARAM} parameters
     * @return Response defined for the command, with {@code $PARAM} replaced by their values extracted in
     * the input command
     */
    private String mapCommand(String[] commandAsArray, String response) {
        List<Integer> positions = this.parameterMapping.get(commandAsArray[0]);
        for (Integer position : positions) {
            //Search by regex, parameters of the form " $PARAM"
            //Specifically, the regex translates to: match any character(s) in a lazy way that start with "$",
            // are preceded by one or more whitespaces and are a separate word.
            response = response.replaceFirst("\\s+\\$.+?\\b", " " + commandAsArray[position]);
        }
        return response;
    }
}
